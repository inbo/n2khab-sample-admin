
```{r}
types <- read_types()
```

# Data sources

+ Selected sampling units for 2021

In 2021 additional sampling units were selected based on the 2020 Habitatmap.

```{r}
su_2021 <- read.csv2("../../output/samplingunits_todo_inbo_versie2021-05-04.csv")

su_anb_2021 <- read.csv2("../../output/samplingunits_prioritair_anb_versie2021-02-22.csv") %>%
    rename(grts_ranking_draw = grts_ranking)
```

+ Standardized table of mhq refpoints, assessments and measurements

These tables contain the originally selected sampling units and the assessments and measurements untill 2019.

```{r}
mhq_terr_assessments <- read_vc("mhq_terr_assessments", 
                                root = "../../data")

mhq_terr_assessments <- mhq_terr_assessments %>%
    filter(!is.na(assessment_date))

# mhq_terr_assessments <- mhq_terr_assessments %>%
#   mutate(type_observed = str_trim(type_observed))
# 
# write_vc(mhq_terr_assessments, "mhq_terr_assessments",
#                                 root = "../../data", strict = FALSE)

mhq_terr_refpoints <- read_vc("mhq_terr_refpoints", 
                                root = "../../data")

mhq_terr_refpoints_check_update <- read_vc("mhq_terr_refpoints_check_update", 
                                root = "../../data")
    
mhq_terr_measurements <- read_vc("mhq_terr_measurements", 
                                root = "../../data")

mhq_terr_refpoints_validity <- read_vc("mhq_terr_refpoints_validity", 
                                root = "../../data")
```


+ Read google sheet data with mhq inbo assessments admin

The INBO fieldwork coordinator uses [this googlesheet](https://docs.google.com/spreadsheets/d/1WkGPPYTb1Xytg5kJeOSxLvt3PUdFjlpPb4rwYG9znys/) to document which sampling units have been assessed. Based on this table we will check the new assessments of 2020 and 2021.

```{r}
gs4_auth("toon.westra@inbo.be")

assessments_admin <- read_sheet(
    "https://docs.google.com/spreadsheets/d/1WkGPPYTb1Xytg5kJeOSxLvt3PUdFjlpPb4rwYG9znys/edit#gid=0",
    col_types = c("ccllcnnncDclncc"), trim_ws = TRUE
    )

assessments_admin <- assessments_admin %>%
    filter(!is.na(assessment_date)) %>%
    mutate(db_ref_orig = db_ref,
        db_ref = ifelse(nchar(db_ref_orig) > 5 & str_detect(db_ref_orig, "_"), str_sub(db_ref_orig, end = str_locate(db_ref_orig, "_") - 1), db_ref_orig)
       )

```

```{r, eval = FALSE}
assessments_admin <- assessments_admin %>%
    filter(!is.na(assessment_date)) %>%
    filter(year(assessment_date) < 2021)

su_2021_check <- su_2021 %>%
    filter(point_code %in% assessments_admin$point_code)

assessments_admin_check <- assessments_admin %>%
    filter(point_code %in% su_2021$point_code)
```

+ assessments and measurement ANB

The assessment data and measurement data of ANB is exported from a Fieldmap database.

```{r}

path <- file.path(fileman_up("n2khab-mhq-data"), "processed/fieldmap_mhq")

assessments_admin_anb <- read_vc(root = path, file = "assessments_openhab") 

assessments_admin_anb <- assessments_admin_anb %>%
    filter(!(info_status_fieldwork == "voldoende opnames beschikbaar" & is.na(type_observed)))

coordinates_anb <- read_vc(root = path, file = "coordinates")  

```


+ Measurements INBOVEG

INBOVEG contains the actual collected data including the coordinates. Only the assessments untill 2020 are imported.

```{r}

path <- file.path(fileman_up("n2khab-mhq-data"), "processed/inboveg_mhq_terr")

header_mhq_terr <- read_vc(root = path, file = "header_mhq_terr") %>%
    mutate(assessment_date = as.Date(vague_date_begin)) 

classif_mhq_terr <- read_vc(root = path, file = "classif_mhq_terr") 

visits_mhq_terr <- header_mhq_terr %>%
    select(user_reference, recording_givid, area, assessment_date, y = latitude, x = longitude) %>%
    left_join(classif_mhq_terr, by = "recording_givid") %>%
    select(-survey, -classif_key) %>%
    mutate(db_ref = str_to_lower(user_reference),
           db_ref = ifelse(str_detect(str_sub(db_ref, 1, 1), "[a-z]"), str_sub(db_ref, 1, 5), db_ref),
           db_ref = ifelse(nchar(db_ref) > 5 & str_detect(db_ref, "_"), str_sub(db_ref, end = str_locate(db_ref, "_") - 1), db_ref)
           )


check_missing_area <- visits_mhq_terr %>%
    filter(is.na(area))

####### TO BE CORRECTED IN INBOVEG ###

# area ontbreekt
visits_mhq_terr <- visits_mhq_terr %>%
    mutate(area = ifelse(recording_givid == "IV2017010617551993", 9, area ))

#deze mogen weg
visits_mhq_terr <- visits_mhq_terr %>%
    filter(! recording_givid %in% c("IV2021011413075093", "IV2019121210481485"))

# user_reference verschilt voor circle and square plot

visits_mhq_terr <- visits_mhq_terr %>%
    mutate(user_reference = ifelse(recording_givid == "IV2021011813214975", "562353", user_reference )) %>%
    mutate(user_reference = ifelse(recording_givid == "IV2021031211544343", "WZ_22", user_reference ))



# set x-coordinate of circle plot to that of the square plot 

# visits_mhq_terr <- visits_mhq_terr %>%
#     mutate(x = ifelse(recording_givid == "IV2021011813155073", 	2.69016334, x ))
           
#####################################


visits_mhq_terr_wide <- visits_mhq_terr %>%
    mutate(cover_description = str_c(type_cover, "% ", type_observed)) %>%
    mutate(plot_type = ifelse(area <= 9, "square", "circle")) %>%
    group_by(db_ref, user_reference, recording_givid, plot_type, assessment_date, x, y) %>%
    summarise(cover_description = str_c(cover_description, collapse = "; ")) %>%
    ungroup() %>%
    st_as_sf(coords = c("x", "y"), crs = 4326) %>%
    st_transform(31370)


visits_mhq_terr_wide <- visits_mhq_terr_wide %>%
    mutate(x_measured = round(st_coordinates(visits_mhq_terr_wide)[,1], 1),
           y_measured = round(st_coordinates(visits_mhq_terr_wide)[,2], 1)) %>%
    st_drop_geometry() %>%
    mutate(recording_givid = str_c(plot_type, ": ", recording_givid)) %>%
    group_by(db_ref, user_reference, assessment_date) %>%
    mutate(recording_givid = str_c(recording_givid, collapse = "; "),
           x_measured = mean(x_measured),
           y_measured = mean(y_measured)) %>%
    ungroup() %>%
    pivot_wider(names_from = "plot_type", values_from = "cover_description") %>%
    group_by(db_ref) %>%
    mutate(n_visits = n()) %>%
    ungroup() %>%
    mutate(db_ref = ifelse(n_visits > 1, user_reference, db_ref)) %>%
    group_by(db_ref) %>%
    mutate(n_db_ref = n()) %>%
    ungroup()

check_measurements_doubles <- visits_mhq_terr_wide %>%
    filter(n_visits > 1)

```

For following records we have two visits for the same grts_ranking. In some cases the two visits have the same user_reference.


```{r}
check_measurements_doubles %>%
    kable() %>%
    kable_styling()
```
For db_ref = 480306 we will keep only the visit of 2018-06-13 as it is closer tot the original reference point.

For db_ref = 1642233 we will keep only the visit of 2018-05-31 as it is closer tot the original reference point.

```{r}
visits_mhq_terr_wide <- visits_mhq_terr_wide %>%
    filter(!(db_ref == "480306" & assessment_date == "2016-06-08")) %>%
    filter(!(db_ref == "1642233" & assessment_date == "2017-06-23")) 
```





+ Coordinates assessments 2021

```{r}
coordinates_2021_orig <- read_csv2("../../mhq_sample-admin_data/field-data/coordinates_inbo/meetpunten2021_coords.csv")

coordinates_2021 <- coordinates_2021_orig %>%
    filter(bezocht == 2021) %>%
    select(point_code, opname, verplaatst, opmerking, polygon_id, x_measured = x, y_measured = y)

```

+ GRTS Flanders

```{r}
grts_master <- read_GRTSmh()
```

+ habmap

```{r}
habmap <- read_habitatmap_stdized()
```


# Update refpoints

## Add selected sampling units 2021

```{r}
reference_points_2021 <- su_2021 %>%
    bind_rows(su_anb_2021) %>%
    mutate(db_ref = str_remove(point_code, "_\\d")) %>%
    anti_join(mhq_terr_refpoints, by = c("sampling_unit_code")) %>%
    mutate(is_centroid = TRUE,
           legacy_site = FALSE,
           grts_ranking = grts_ranking_draw,
           check_point_code = point_code %in% mhq_terr_refpoints$point_code,
           point_code = ifelse(point_code %in% mhq_terr_refpoints$point_code,
                               str_c(str_remove(point_code, "_\\d"), "_2"),
                               point_code)) %>%
    select(sampling_unit_code, point_code, grts_ranking, is_centroid, grts_ranking_draw, legacy_site, x, y, sac, db_ref, type_target)

reference_points_update <- mhq_terr_refpoints_check_update %>%
    select(-scheme, -year_planned) %>%
    bind_rows(reference_points_2021)

check_unique_point_code_type <- reference_points_update %>%
    group_by(point_code, type_target) %>%
    mutate(n = n()) %>%
    ungroup() %>%
    filter(n > 1)
```

## Check 6410 

Do to changes in habitat definition most of the measurents of 6410_ve should actually be 6410_mo. This can be seen in the table below in which 'bwk_description' provides the habitat description according to the 2020 version of the habitatmap.

```{r}
refpoints_6410_ve_to_mo <- reference_points_update %>%
  filter(type_target == "6410_ve") %>%
  st_as_sf(coords = c("x", "y"), crs = 31370) %>%
  st_join(habmap$habitatmap_polygons) %>%
  st_drop_geometry() %>%
  select(point_code, type_target,  bwk_description = description_orig) %>%
  mutate(changesubtype_to_mo = str_detect(bwk_description, "_mo")) %>%
  filter(changesubtype_to_mo) %>%
    mutate(type_target = "6410_mo") %>%
    anti_join(reference_points_update, by = c("type_target", "point_code"))


refpoints_6410_ve_to_mo %>%
  kable() %>%
    kable_styling()

reference_points_update <- reference_points_update %>%
    mutate(type_target = ifelse(type_target == "6410_ve" & (point_code %in% refpoints_6410_ve_to_mo$point_code),
                         "6410_mo",
                         type_target),
          sampling_unit_code = ifelse(str_detect(sampling_unit_code,"6410_ve") & (point_code %in% refpoints_6410_ve_to_mo$point_code),
                         str_c(grts_ranking_draw, "_6410_mo"),
                         sampling_unit_code)
    )
    
```


# Update assessments


```{r}
new_point_code <- mhq_terr_refpoints_check_update %>%
    anti_join(mhq_terr_refpoints, by = "point_code")

# assessments_admin_long <- assessments_admin %>%
#     separate_rows(type_target_all, sep = "\\+") %>%
#     rename(type_target = type_target_all) %>%
#     mutate(type_target = str_trim(type_target)) %>%
#     filter(!is.na(assessment_date))

assessments_admin_basic <- assessments_admin %>%
    mutate(db_ref = ifelse(db_ref_orig %in% check_measurements_doubles$db_ref, db_ref_orig, db_ref)) %>%
    # mutate(point_code_original = ifelse(point_code %in% c(reference_points_update$point_code, su_2021$point_code), point_code,
    #                                     str_c(str_sub(point_code, end = -2), "1"))) %>%
    group_by(point_code) %>%
    mutate(lsvi_measurement = any(lsvi_measurement),
           check_type_observed = any(!is.na(type_observed))) %>%
    ungroup() %>%
    filter(!(is.na(type_observed) & check_type_observed)) %>%
    distinct(fieldwork_team, point_code, db_ref, assessment_source, assessment_date, inaccessible, lsvi_measurement, type_observed) %>%
    # select(fieldwork_team, point_code = point_code_original, everything()) %>%
    group_by(fieldwork_team, point_code) %>%
    mutate(n_points = n()) %>%
    ungroup() %>%
    mutate(point_type = ifelse(point_code %in% new_point_code$point_code, "replacement", "original"))
    # group_by(fieldwork_team, db_ref) %>%
    # mutate(n_db_ref = n(db_ref)) %>%
    # ungroup() %>%
    # mutate(db_ref = ifelse(n_db_ref >= 2 & !is.na(type_observed), str_c(db_ref, "_", type_observed), db_ref)) %>%
    # unique()

check_doublepoint_code <- assessments_admin_basic %>%
    filter(n_points >= 2)

check_double_db_ref <- assessments_admin_basic %>%
    group_by(fieldwork_team, db_ref) %>%
    mutate(n_db_ref = n(),
           n_measurement = sum(lsvi_measurement)) %>%
    ungroup() %>%
    filter(n_db_ref >= 2 & n_measurement >= 2)

check <- assessments_admin_basic %>%
    anti_join(reference_points_update, by = "point_code")



# coordinates_refpoints <- mhq_terr_refpoints_check_update %>%
#     mutate(x = round(x, 1),
#            y = round(y, 1))
# 
# check_coordinates <- coordinates_refpoints %>%
#     group_by(point_code) %>%
#     mutate(coordinates_match = n_distinct(x) == 1 & n_distinct(y) == 1) %>%
#     ungroup() %>%
#     filter(!coordinates_match)
#  
# coordiantes_refpoints_2021 <- su_2021 %>%
#     distinct(point_code, x, y) %>%
#     left_join(coordinates_refpoints, by = c("point_code"), suffix = c("_sample_2021", "_mhq_refpoints")) %>%
#     mutate(distance = sqrt((x_sample_2021 - x_mhq_refpoints)^2 + (y_sample_2021 - y_mhq_refpoints)^2))

# # refpoints that are in the admin table but not in mhq_terr_refpoints
# coordinates_refpoints2021_new <- coordiantes_refpoints_2021 %>%
#     filter(is.na(distance)) %>%
#     select(point_code, x = x_sample_2021, y = y_sample_2021) %>%
#     mutate(x = round(x, 2),
#            y = round(y, 2))
# 
# # refpoints that are in the admin table and not in mhq_terr_refpoints, but admin table contains measured coordinates, not original
# coordinates_refpoints2021_new2 <- coordiantes_refpoints_2021 %>%
#     filter(distance > 2) %>%
#     select(point_code, x = x_sample_2021, y = y_sample_2021) %>%
#     mutate(point_code = str_c(str_sub(point_code, end = -2), "2"),
#            x = round(x, 2),
#            y = round(y, 2))
# 
# coordinates_refpoints_all <- coordinates_refpoints %>%
#     bind_rows(coordinates_refpoints2021_new) %>%
#     bind_rows(coordinates_refpoints2021_new2)
# 
# check <- coordinates_refpoints_all %>%
#     group_by(point_code) %>%
#     filter(n() > 1) %>%
#     ungroup()
# 
# assessments_admin_new <- assessments_admin_new %>%
#     left_join(coordinates_refpoints_all, by = "point_code", suffix = c("_admin", "_original")) %>%
#     filter(fieldwork_team == "inbo") 


```

## Assessments INBO

### Link assessments to measurements INBO

```{r}

assessments_admin_inboveg_measured <- assessments_admin_basic %>%
    filter(fieldwork_team == "inbo") %>%
    filter(lsvi_measurement) %>%
    inner_join(visits_mhq_terr_wide, by = "db_ref", suffix = c("_admin", "_inboveg")) 

assessments_admin_notinboveg_measured <- assessments_admin_basic %>%
    filter(fieldwork_team == "inbo") %>%
    filter(lsvi_measurement) %>%
    inner_join(select(coordinates_2021, point_code, x_measured, y_measured), by = "point_code") %>%
    anti_join(assessments_admin_inboveg_measured, by = "point_code") %>%
    rename(assessment_date_admin = assessment_date) %>%
    unique()

check <- assessments_admin_notinboveg_measured %>%
    semi_join(assessments_admin_inboveg_measured, by= "point_code") 

assessments_admin_other <- assessments_admin_basic %>%
    anti_join(assessments_admin_inboveg_measured, by = "point_code") %>%
    anti_join(assessments_admin_notinboveg_measured, by = "point_code") %>% 
    rename(assessment_date_admin = assessment_date) %>%
    filter(fieldwork_team == "inbo") 

assessments_admin_inboveg <- bind_rows(assessments_admin_inboveg_measured,
                                    assessments_admin_notinboveg_measured,
                                    assessments_admin_other) %>%
    arrange(point_code)

check_unique_point_code <- assessments_admin_inboveg %>%
    group_by(point_code, assessment_date_inboveg) %>%
    mutate(n_point_code = n()) %>%
    ungroup() %>%
    filter(n_point_code > 1)

mhq_refpoints_sf <- reference_points_update %>%
    st_as_sf(coords = c("x", "y"), crs = 31370) %>%
    select(point_code_refpoint = point_code, sampling_unit_code, db_ref_refpoint = db_ref)

check_missing_admin <- visits_mhq_terr_wide %>%
    anti_join(assessments_admin_basic, by = "db_ref") %>%
    st_as_sf(coords = c("x_measured", "y_measured"), crs = 31370) %>%
    st_join(mhq_refpoints_sf, join = st_nearest_feature)

check_missing_inboveg <- assessments_admin_inboveg %>%
    filter(lsvi_measurement) %>%
    anti_join(visits_mhq_terr_wide, by = "db_ref") %>%
    filter(year(assessment_date_admin) < 2021)

check_missing_coord_2021 <- assessments_admin_inboveg %>%
    filter(lsvi_measurement) %>%
    anti_join(coordinates_2021, by = "point_code") %>%
    filter(year(assessment_date_admin) >= 2021) %>%
    filter(type_observed != "91E0_sf")

```

+ For following records it is indicated in the admin table that an LSVI-measurement was performed. However no INBOVEG record can be found.

```{r}
check_missing_inboveg %>%
    select(point_code, db_ref, assessment_date_admin, lsvi_measurement) %>%
    kable() %>%
    kable_styling()
```

+ For following INBOVEG measurements we do not find a record in the admin table

```{r}
check_missing_admin %>%
    select(db_ref, user_reference, recording_givid, assessment_date) %>%
    kable() %>%
    kable_styling()
```

+ For following 2021 assessments the measured coordinates are missing

```{r}
check_missing_coord_2021 %>%
    select(point_code, type_observed, lsvi_measurement) %>%
    kable() %>%
    kable_styling()
```



+ For following assessments the assessment date in the admin table does not match the one in INBOVEG. We assume the INBOVEG date is the correct one.

```{r}
check_assessment_date <- assessments_admin_inboveg %>%
    filter(!is.na(assessment_date_inboveg)) %>%
    filter(assessment_date_admin != assessment_date_inboveg) %>%
    filter(month(assessment_date_admin) != 1)


check_assessment_date %>%
    select(point_code, db_ref, assessment_date_admin, assessment_date_inboveg)
```
```{r}
assessments_admin_inboveg <- assessments_admin_inboveg %>%
    mutate(assessment_date = if_else(!is.na(assessment_date_inboveg), assessment_date_inboveg, assessment_date_admin))
```

+ For following assessments the observed type in the admin table is missing. We assume that teh observed type in the square plot of the INBOVEG date is the correct one.

```{r}
check_type_observed <- assessments_admin_inboveg %>%
    filter(lsvi_measurement) %>%
    filter(is.na(type_observed)) %>%
    # filter(!is.na(user_reference)) %>%
    mutate(one_type = str_sub(square, 1, 3) == "100")

check_one_type <- all(check_type_observed$one_type)

assessments_admin_inboveg <- assessments_admin_inboveg %>%
    mutate(type_observed = ifelse(is.na(type_observed) & lsvi_measurement, str_sub(square, start = 6), type_observed))
```

```{r}
check_type_observed %>%
    select(point_code, db_ref, assessment_date_admin, type_observed, square) %>%
    kable() %>%
    kable_styling()
```



### Link assessments to refpoints

```{r}

refpoints_assessed <- reference_points_update %>%
    group_by(point_code, is_centroid, legacy_site, sac, grts_ranking, grts_ranking_draw) %>%
    summarise(type_target_all = str_c(type_target, collapse = ";"),
              x = mean(x),
              y = mean(y)) %>%
    ungroup()

check <- refpoints_assessed %>%
    group_by(point_code) %>%
    filter(n() > 1) %>%
    ungroup()

refpoints_assessed_inbo <- refpoints_assessed %>%
    inner_join(assessments_admin_inboveg, by = "point_code") %>%
    distinct() %>%
    mutate(distance = sqrt((x_measured - x)^2 + (y_measured - y)^2))

check_double_su <- refpoints_assessed_inbo %>%
    group_by(point_code, type_target_all, assessment_date) %>%
    mutate(n_pointcode = n()) %>%
    ungroup() %>%
    filter(n_pointcode > 1)

check_coordinates <- refpoints_assessed_inbo %>%
    filter(distance >= 1, point_type == "replacement")
```

+ For following refpoints the coordiantes in INBOVEG do not match the coordinates in the admin table

```{r}
check_coordinates %>%
    select(point_code, db_ref, type_observed, x, y, x_measured, y_measured, distance)
```

## Assessments ANB

### Assessments in Fieldmap

```{r}
coordinates_anb <- coordinates_anb %>%
    mutate(plot_id = as.character(plot_id)) %>%
    select(plot_id, x_measured, y_measured)

refpoints_assessed_anb <- reference_points_update %>%
    mutate(point_type = ifelse(point_code %in% new_point_code$point_code, "replacement", "original")) %>%
    filter(point_type != "replacement") %>%
    group_by(point_code) %>%
    mutate(type_target_all = str_c(type_target, collapse = ";")) %>%
    ungroup() %>%
    select(sampling_unit_code, grts_ranking, grts_ranking_draw, is_centroid, sac, legacy_site, point_code, type_target_all, x, y) %>%
    inner_join(assessments_admin_anb, by = "sampling_unit_code") %>%
    left_join(coordinates_anb, by = "plot_id") %>%
    mutate(distance = sqrt((x - x_measured) ^ 2 + (y - y_measured) ^ 2),
           type_observed = ifelse(type_observed == "onbekend" & info_status_fieldwork == "nvt - geen doelhabitat", NA, type_observed)) %>%
    mutate(point_type = ifelse(point_code %in% new_point_code$point_code, "replacement", "original"))

refpoints_remove <- reference_points_update %>%
    mutate(point_type = ifelse(point_code %in% new_point_code$point_code, "replacement", "original")) %>%
    filter(point_type == "replacement") %>%
    semi_join(assessments_admin_anb, by = "sampling_unit_code") %>%
    select(point_code, sampling_unit_code)

reference_points_update  <- reference_points_update %>%
    anti_join(refpoints_remove, by = "point_code")

check <- assessments_admin_anb %>%
    anti_join(refpoints_assessed_anb, by = "sampling_unit_code")

check_unique_point_code <- refpoints_assessed_anb %>%
    group_by(point_code) %>%
    filter(n() > 1)

check_unique_su<- refpoints_assessed_anb %>%
    group_by(sampling_unit_code) %>%
    filter(n() > 1)

# dubbele coödinaten voor 2 meetpunten: we selecteren coördinaten dichtst bij originele meetpunt

refpoints_assessed_anb <- refpoints_assessed_anb %>%
    group_by(point_code) %>%
    filter(distance == min(distance) | is.na(distance)) %>%
    ungroup() %>%
    mutate(fieldwork_team = "anb") %>%
    select(point_code, is_centroid, legacy_site, sac, grts_ranking, grts_ranking_draw, type_target_all, type_observed, x, y, fieldwork_team, db_ref = plot_id, assessment_source, assessment_date = date_assessment, inaccessible, not_measurable, lsvi_measurement, x_measured, y_measured, distance, point_type)
    

```

### Assessments not in Fieldmap: orthophoto check

```{r}
#orthocheck before 2020
refpoints_assessed_anb_ortho <- mhq_terr_assessments %>%
    filter(fieldwork_team == "anb" & assessment_source == "orthophoto") %>%
    left_join(select(reference_points_update, point_code, grts_ranking, grts_ranking_draw, is_centroid, legacy_site, sac), by = "point_code") %>%
    unique()

#orthocheck 2021
samples_prioritair_foresthab_anb_check_orig <- read.csv2("../../mhq_sample-admin_data/visual_control_samplingunits/sampling_units_prioritair_foresthab_anb_versie2021-02-08_dektopcheck.csv", stringsAsFactors = FALSE) %>%
  rename(orthocontrole = orthocheck)

samples_prioritair_openhab_anb_check_orig <- read.csv2("../../mhq_sample-admin_data/visual_control_samplingunits/sampling_units_prioritair_openhab_anb_versie2021-02-08_desktopcheck.csv", stringsAsFactors = FALSE) %>%
  rename(opmerking = opm)

samples_extra_orig <- read.csv2("../../mhq_sample-admin_data/visual_control_samplingunits/sampling_unit_prioritair_extra.csv", stringsAsFactors = FALSE) %>%
  rename(orthocontrole = orthocheck)

orthocontrole_2021 <- bind_rows(
  samples_prioritair_foresthab_anb_check_orig,
  samples_prioritair_openhab_anb_check_orig,
  samples_extra_orig
) %>%
  filter(!orthocontrole) %>%
    mutate(is_type_target = ifelse(opmerking == "ontoegankelijk", NA, FALSE),
           type_observed = NA,
           assessment_source = ifelse(opmerking == "ontoegankelijk", NA, "orthophoto"),
           inaccessible = ifelse(opmerking == "ontoegankelijk", "long term", NA),
           assessment_date = as.Date("2021-02-08"),
           fieldwork_team = "anb",
           grts_ranking = grts_ranking_draw,
           is_centroid = TRUE,
           legacy_site = FALSE
           ) %>%
    select(point_code, type_target, is_centroid, legacy_site, grts_ranking, grts_ranking_draw, sac, is_type_target, type_observed, assessment_source, assessment_date, inaccessible, fieldwork_team, x, y)

refpoints_assessed_anb_ortho <- refpoints_assessed_anb_ortho %>%
    bind_rows(orthocontrole_2021) %>%
    anti_join(refpoints_assessed_anb, by = "point_code") %>%
    anti_join(refpoints_assessed_inbo, by = "point_code") %>%
    group_by(point_code, is_centroid, legacy_site, grts_ranking, grts_ranking_draw, sac, type_observed, assessment_source, assessment_date, inaccessible, fieldwork_team, x, y) %>%
    summarise(type_target_all = str_c(type_target, collapse = ";")) %>%
    ungroup() %>%
    mutate(lsvi_measurement = FALSE,
           point_type = "original")


```

### Combine

```{r}
refpoints_assessed_all <- refpoints_assessed_inbo %>%
    select(point_code, is_centroid, legacy_site, sac, grts_ranking, grts_ranking_draw, type_target_all, type_observed, x, y, fieldwork_team, db_ref, assessment_source, assessment_date, inaccessible, lsvi_measurement, x_measured, y_measured, user_reference, recording_givid, distance, point_type) %>%
    bind_rows(refpoints_assessed_anb) %>%
    bind_rows(refpoints_assessed_anb_ortho) %>%
    arrange(grts_ranking)
```


```{r}
# status of each survey event defined?
check_status <- refpoints_assessed_all %>%
    filter(is.na(assessment_source) & is.na(inaccessible) & is.na(not_measurable))

check_unique_point_code <- refpoints_assessed_all %>%
    group_by(point_code) %>%
    filter(n() > 1)

# when assessment by inbo and anb for the same point code, select assessment with measurement
refpoints_assessed_all <- refpoints_assessed_all %>%
    group_by(point_code) %>%
    filter(n() == 1 | (n() > 1 & lsvi_measurement)) %>%
    ungroup()

check_unique_point_code <- refpoints_assessed_all %>%
    group_by(point_code) %>%
    filter(n() > 1)
```


# Create new refpoints for replaced population units

```{r}
max_n <- reference_points_update %>%
    mutate(point_type = ifelse(point_code %in% new_point_code$point_code, "replacement", "original"),
           ) %>%
    select(point_code) %>%
    separate(col = point_code, into = c("left_part", "right_part"), sep = "_", remove = FALSE) %>%
    mutate(right_part = as.numeric(right_part)) %>%
    group_by(left_part) %>%
    mutate(max_n_point_code = max(right_part)) %>%
    ungroup() %>%
    select(point_code, max_n_point_code) %>%
    unique()

distance_from_centroidgrid <- function(min_x, min_y, measured_x, measured_y, resolution = 32, threshold = 1) {
    
    difference_x <- (measured_x - min_x) %% resolution
    shortest_distance_x <- min(difference_x, resolution - difference_x)
    difference_y <- (measured_y - min_y) %% resolution
    shortest_distance_y <- min(difference_y, resolution - difference_y)
    distance_from_grid <- sqrt( shortest_distance_x ^ 2 + shortest_distance_y ^ 2)
    
    return(distance_from_grid)
}


min_x <- (mhq_terr_refpoints %>%
    filter(is_centroid) %>%
    filter(x == min(x)))$x

min_y <- (mhq_terr_refpoints %>%
    filter(is_centroid) %>%
    filter(y == min(y)))$y

new_reference_points <- refpoints_assessed_all %>%
    filter(point_type == "original",
           distance >= 1) %>%
    left_join(max_n, by = "point_code") %>%
    group_by(point_code) %>%
    mutate(ranking_code = str_sub(point_code, end = -3),
           x = x_measured,
           y = y_measured,
           distance_centroid = distance_from_centroidgrid(min_x = min_x,
                              min_y = min_y,
                              measured_x = x_measured,
                              measured_y = y_measured),
           is_centroid = distance_centroid < 1,
           legacy_site = FALSE,
           point_type = "replacement") %>%
    ungroup() %>%
    st_as_sf(coords = c("x", "y"), crs = 31370) %>%
    mutate(grts_ranking = grts_master[as(., "Spatial")]) %>%
    st_drop_geometry() %>%
    mutate(x = x_measured,
           y = x_measured) %>%
    group_by(ranking_code) %>%
    mutate(point_code = str_c(ranking_code, "_", max_n_point_code + rank(x, y, ties.method = "min"))) %>%
    ungroup()

check <- new_reference_points %>%
    semi_join(reference_points_update, by = "point_code")

original_reference_points <- refpoints_assessed_all %>%
    filter(point_type == "original",
           distance >= 1) %>%
    mutate(lsvi_measurement = FALSE,
           type_observed = NA,
           distance = NA,
           x_measured = NA,
           y_measured = NA,
           user_reference = NA,
           recording_givid = NA)

refpoints_assessed_all <- refpoints_assessed_all %>%
    anti_join(original_reference_points, by = "point_code") %>%
    bind_rows(original_reference_points) %>%
    bind_rows(new_reference_points)

check_unique_point_code <- refpoints_assessed_all %>%
    group_by(point_code) %>%
    filter(n() > 1)
```

# Standardise tables

## Reference points

terr_refpoints (git2rdata object): defines the reference point for the terrestrial population units and grts-ranking for this refpoint

+ point_code: the id of the reference point
+ is_centroid: is the reference point located in the center of a grts-master grid cell
+ grts_ranking
+ x: x-coordinate (crs = 31370)
+ y: y-coordinate (crs = 31370)

```{r}
reference_points_notassessed <-  reference_points_update %>%
    anti_join(refpoints_assessed_all, by = "point_code") %>%
    group_by(point_code, is_centroid, legacy_site, grts_ranking) %>%
    summarise(x = mean(x),
              y = mean(y))

terr_refpoints <- refpoints_assessed_all %>%
    mutate(x = ifelse(!is.na(x_measured), round(x_measured, 2), round(x, 2)),
           y = ifelse(!is.na(y_measured), round(y_measured, 2), round(y,2))) %>%
    bind_rows(reference_points_notassessed) %>%
    select(point_code, is_centroid, grts_ranking,  x, y) %>%
    unique()

check <- terr_refpoints %>%
    group_by(point_code) %>%
    filter(n() > 1) %>%
    ungroup()

```

```{r}
terr_refpoints %>%
    slice_head(n = 10) %>%
    kable() %>%
    kable_styling()
```


## Assessments

terr_assessments contains the assessment for the monitoring habitat quality programme

+ assessment_date: date of the assessment
    + If the target type was not observed, the assessment year was not recorded. In this case we take the median of the
    years in which the assessments took place.
+ point_code: the id of the point_code
+ type: the evaluated type
+ is_present:
    + TRUE if the evaluated type was observed
    + FALSE if the evaluated type was not observed
    + NA if no assessment could be performed (inaccessible) or if the type’s presence is unknown
+ no_habitat:
    + TRUE if no habitat type was observed,  altough a regional import biotope (rib) type might be present (the presence of rib types was not evaluated)
    + FALSE when any type is present,
    + NA when the evaluated type is absent or unknown and it is not known if any other type is present (in case the point is inaccessible)
+ assessment_source: field assessment or orthophoto
+ inaccessible: long term or short term
+ not_measurable: long term or short term
+ change_location: has the population unit been replaced

```{r}
types <- read_types()

#unique(refpoints_assessed_all$type_observed)

terr_assessments <- refpoints_assessed_all %>%
    mutate(is_present = ifelse(is.na(type_observed) & is.na(inaccessible) & is.na(not_measurable), FALSE,
                               type_observed %in% types$type),
           is_present = ifelse(type_observed == "onbekend" & !is.na(type_observed), NA, is_present),
           no_habitat = ifelse(type_observed %in% c("gh", "geen habitat (akker, houtkant, tuin,...)", "infrastructuur"), TRUE, 
                               ifelse(type_observed %in% types$type, FALSE, NA)),
           type = ifelse(is_present & !is.na(is_present), type_observed, type_target_all),
           change_location = point_type == "replacement"
           ) %>%
    select(assessment_date, point_code, type, is_present, no_habitat, assessment_source, inaccessible, not_measurable, change_location) %>%
    separate_rows(type, sep = ";") %>%
    mutate(type = factor(type, levels = levels(types$type)))

check <- terr_assessments %>%
    group_by(assessment_date, point_code, type) %>%
    filter(n() > 1) %>%
    ungroup()

check_refpoint <- terr_assessments %>%
    anti_join(terr_refpoints, by = "point_code")
```

```{r}
terr_assessments %>%
    slice_head(n = 10) %>%
    kable() %>%
    kable_styling()
```


## Measurements

mhq_terr_measurements: table with information on measurements

+ measurement_date
+ point_code: the id of the watersurface according to the data source watersurfaces_hab and/or watersurfaces
+ user_reference: reference to record in INBOVEG database
+ recording_givid
+ type: the observed type


```{r}
terr_measurements <- refpoints_assessed_all %>%
    filter(lsvi_measurement) %>%
    select(fieldwork_team, point_code, type = type_observed, measurement_date = assessment_date, db_ref, user_reference, recording_givid) %>%
    mutate(type = factor(type, levels = levels(types$type))) %>%
    arrange(measurement_date)

check <- terr_measurements %>%
    group_by(point_code, measurement_date) %>%
    filter(n() > 1)
```


```{r}
terr_measurements %>%
    slice_head(n = 10) %>%
    kable() %>%
    kable_styling()
```


## Population units

The table mhq_terr_popunits contains the population units which have been assessed or which have been considered for assessment in mhq. 
It contains following variabeles:

+ point_code
+ grts_ranking
+ grts_ranking_draw: the grts_ranking which is used for drawing the sample
+ sac: located in N2000 special area of conservation
+ legacy_site: population that are used as sampling units in other monitoring programmes and have been included in mhq
+ type
+ assessed: has the population unit already been assessed
+ polygon_id: id of habitatmap polygon in which the population unit is located 
+ phab: fraction (%) of the habitatmap polygon covered by the type


```{r}

terr_popunits <- reference_points_update %>%
    rename(type = type_target) %>%
    mutate(assessed = point_code %in% terr_assessments$point_code) %>%
    left_join(select(terr_assessments, point_code, assessment_date, no_habitat), by = c("point_code")) %>%
    left_join(select(terr_assessments, point_code, type, is_present), by =c("point_code", "type")) %>%
    mutate(is_present = ifelse(assessed & is.na(is_present), FALSE, is_present)) %>%  #hier is een ander habitattype waargenomen
    filter(is_present | (!assessed)) %>%
    select(point_code,  grts_ranking, grts_ranking_draw, sac, legacy_site, type, assessed, x, y)
    

terr_popunits_new_assessment <- terr_assessments %>%
    filter(is_present) %>%
    anti_join(terr_popunits, by = c("point_code", "type")) %>%
    left_join(terr_refpoints, by = "point_code") %>%
    left_join(select(refpoints_assessed_all, point_code, grts_ranking_draw, sac, legacy_site), by = "point_code")  %>%
    mutate(assessed = TRUE) %>%
    select(point_code,  grts_ranking, grts_ranking_draw, sac, legacy_site, type, assessed, x, y)

terr_popunits <- terr_popunits %>%
    bind_rows(terr_popunits_new_assessment)

# if assessed only one type per point_code possible
check <- terr_popunits %>%
    filter(assessed) %>%
    group_by(point_code) %>%
    filter(n() > 1)

types_phab <- habmap$habitatmap_types %>%
    select(polygon_id, type, phab) %>%
    mutate(type = if_else(type != "2190", type, factor("2190_overig"))) %>%
    group_by(polygon_id, type) %>%
    summarise(phab = sum(phab)) %>%
    ungroup()

terr_popunits_sf <- terr_popunits %>%
    st_as_sf(coords = c("x", "y"), crs = 31370) %>%
    st_join(select(habmap$habitatmap_polygons, polygon_id, description_orig)) %>%
    st_drop_geometry() %>%
    mutate(match_type = str_detect(description_orig, str_remove(type, "_overig")),
           remove = (!assessed) & (!match_type | is.na(description_orig))) %>%
    left_join(types_phab, by = c("polygon_id", "type"))

terr_popunits <- terr_popunits_sf %>%
    filter(!remove) %>%
    mutate(source = ifelse(is.na(polygon_id) | !match_type, "assessment",
                           ifelse(assessed, "assessment/habitatmap 2020", "habitatmap 2020"))) %>%
    select(-description_orig, -match_type, -remove, -assessed) 

```









### Check assessments

```{r}
grts_max_ranking <- reference_points_update %>%
    group_by(sac, type_target) %>%
    summarise(max_ranking = max(grts_ranking_draw)) %>%
    ungroup() %>%
    rename(type_observed = type_target)

assessments_admin_check <- refpoints_assessed %>%
    left_join(grts_max_ranking, by = c("type_observed", "sac")) %>%
    mutate(distance =ifelse(lsvi_measurement, sqrt((x - x_measured) ^ 2 + (y - y_measured) ^ 2), 0),
           distance = round(distance, 2),
           is_type_target = ifelse(nchar(type_target) == 4, str_sub(type_observed, 1, 4) == type_target,
                               type_observed == type_target),
           is_type_target = ifelse((!lsvi_measurement) & is.na(type_observed), FALSE, is_type_target),
           replacement = (distance > 1) | (point_type == "replacement"),
           is_maintype_target = str_sub(type_observed, 1, 4) == str_sub(type_target, 1, 4)
           ) %>%
    group_by(point_code) %>%
    mutate(any_type_target = any(is_type_target)) %>%
    ungroup() 
```

+ check anomaly coordinates

```{r}
assessments_admin_check_anomaly <- assessments_admin_check %>%
    filter(point_type == "replacement", distance > 0.1)
```




### Check 2020 and earlier assessments

```{r}

grts_max_ranking <- reference_points_update %>%
    group_by(sac, type_target) %>%
    summarise(max_ranking = max(grts_ranking_draw)) %>%
    ungroup() %>%
    rename(type_observed = type_target)

assessments_admin_until2020 <- refpoints_assessed %>%
    filter(year(assessment_date) <= 2020) %>%
    left_join(grts_max_rankicng, by = c("type_observed", "sac")) %>%
    mutate(distance =ifelse(lsvi_measurement, sqrt((x - x_measured) ^ 2 + (y - y_measured) ^ 2), 0),
           distance = round(distance, 2),
           is_type_target = ifelse(nchar(type_target) == 4, str_sub(type_observed, 1, 4) == type_target,
                               type_observed == type_target),
           is_type_target = ifelse((!lsvi_measurement) & is.na(type_observed), FALSE, is_type_target),
           replacement = (distance > 1) | (point_code == "replacement"),
           is_maintype_target = str_sub(type_observed, 1, 4) == str_sub(type_target, 1, 4)
           ) %>%
    group_by(point_code) %>%
    mutate(any_type_target = any(is_type_target)) %>%
    ungroup() %>%
    mutate(allow_other_type = ifelse(!any_type_target, 
                                     grts_ranking_draw <= max_ranking & (!(replacement & !is_maintype_target)),
                                     NA),
           is_valid_type = is_type_target | (allow_other_type & !is.na(allow_other_type)),
           is_valid_refpoint = distance <= 110 | is.na(distance),
           is_valid = is_valid_type & is_valid_refpoint)


    
```





+ We allow a measurement for another type than the target type when:
    + grts_ranking_draw is smaller than the maximum ranking of the observed type, AND
    + when the observed type and the target type do not belong to the same main type, the reference point is not replaced
    
In the table below we see that these conditions are not met in several occasions.


```{r}
check_allow_other_type <- assessments_admin_until2020 %>%
    filter(!allow_other_type) %>%
    select(db_ref, sac ,type_target, type_observed, assessment_date, grts_ranking_draw, max_ranking, distance, allow_other_type)

check_allow_other_type %>%
    arrange(desc(assessment_date)) %>%
    kable() %>%
    kable_styling()
```



+ Create new sampling units when allow_other_type is TRUE

When a reference point is measured and the observed type is different from the target type, we create a new sampling unit within the scheme of the observed type. We only do this for valid assessments (allow_other_type = TRUE and distance_from refpoint)

```{r}
    new_sampling_units_2020 <- assessments_admin_until2020 %>%
        filter(lsvi_measurement) %>%
        filter(allow_other_type) %>%
    select(-sampling_unit_code) %>%
    mutate(type_target = type_observed,
           is_type_target = TRUE,
           any_type_target = TRUE,
           is_valid = TRUE,
           is_valid_type = TRUE,
           allow_other_type = NA) %>%
    unique()

```


```{r}
assessments_admin_until2020 <- bind_rows(
    assessments_admin_until2020,
    new_sampling_units_2020
) %>% 
    arrange(type_target, sac, grts_ranking_draw) %>%
    select(-sampling_unit_code)

```

+ Handle reference point changes

When lsvi is measured at a different location than the original reference point, we create a new point_code for the reference point. 
This is done by adding adding 1 to the number at the end of the point_code.  
We consider a reference point as changed when the difference between the measured location and the original reference point is larger than 2 meter. Smaller differences are assumed unintentional.  

Next we create assessments for the original reference points. It is assumed that for the changed locations, the target type is not present in the original reference point.

```{r}
sample_units_change_location_until2020 <-  assessments_admin_until2020 %>%
    filter(distance > 1 & point_code %in% mhq_terr_refpoints$point_code) %>%
    mutate(ranking_code = str_sub(point_code, end = -3),
           n_temp = as.numeric(str_sub(point_code, start = -1)),
           x = x_measured,
           y = y_measured,
           is_centroid = FALSE,
           legacy_site = FALSE) %>%
    st_as_sf(coords = c("x", "y"), crs = 31370) %>%
    mutate(grts_ranking = grts_master[as(., "Spatial")]) %>%
    st_drop_geometry() %>%
    mutate(x = x_measured,
           y = x_measured) %>%
    group_by(ranking_code) %>%
    mutate(point_code = str_c(ranking_code, "_", max(n_temp) + rank(x, y, ties.method = "min"))) %>%
    ungroup()

#check: no lsvi measurement AND location change

check <- sample_units_change_location_2020 %>%
    filter(distance > 1) %>%
    filter(!lsvi_measurement)

sample_units_update_orig_location_2020 <- assessments_admin_new_2020 %>%
    filter(distance > 2) %>%
    mutate(is_type_target = FALSE,
         lsvi_measurement = FALSE,
          x = x_original,
           y = y_original,
           is_valid = FALSE,
           is_valid_type = FALSE,
           is_valid_refpoint = TRUE,
           allow_other_type = NA,
           type_observed = NA,
           cover_description = NA,
           distance = 0)
    
assessments_admin_new_2020_2 <- assessments_admin_new_2020 %>%
    filter(distance < 2 | is.na(distance)) %>%
    mutate(x = ifelse(is.na(x_measured), x_original, x_measured),
           y = ifelse(is.na(y_measured), y_original, y_measured)) %>%
    bind_rows(sample_units_change_location_2020) %>%
    bind_rows(sample_units_update_orig_location_2020) %>%
    arrange(point_code) %>%
    filter(fieldwork_team == "inbo")


```



### Check 2021 assessments

In 2021 we started with a new sampling strategy. When the target type is not observed in a sampling unit, we allow it to be replaced by the sampling unit that does contain the target type with the lowest grst-ranking, within the same habitatmap polygon. 

```{r}

grts_max_ranking_2021 <- su_2021 %>%
    filter(!is.na(max_grts_ranking)) %>%
    distinct(sac, type_target, max_grts_ranking) %>%
    rename(type_observed = type_target)

assessments_admin_new_2021 <- assessments_admin_new %>%
    filter(year(assessment_date) >= 2021) %>%
    left_join(coordinates_2021, by = c("point_code")) %>%
    left_join(grts_max_ranking_2021, by = c("type_observed", "sac")) %>%
    mutate(distance = sqrt((x_original - x_measured) ^ 2 + (y_original - y_measured) ^ 2),
           distance = round(distance, 3),
           is_type_target = ifelse(nchar(type_target) == 4, str_sub(type_observed, 1, 4) == type_target,
                               type_observed == type_target)) %>%
    group_by(point_code) %>%
    mutate(any_type_target = any(is_type_target)) %>%
    ungroup() %>%
    mutate(allow_other_type = ifelse(!any_type_target, grts_ranking_draw <= max_grts_ranking & distance <= 1,
                                     NA))
```



+ check allow other type

```{r}
check_allow_other_type <- assessments_admin_new_2021 %>%
    filter(lsvi_measurement) %>%
    filter(!allow_other_type) %>%
    select(db_ref ,type_target, type_observed, assessment_date, grts_ranking_draw, max_grts_ranking, distance, allow_other_type)

```

The table below shows one invalid measurement.

```{r}

check_allow_other_type %>%
    kable() %>%
    kable_styling()
```




+ Check replacements


A replacement is correct when:

+ the new reference point is within the same polygon than the replaced refrence point
+ the new reference point is in the center of the grid cell

The map below shows:
+ the habitatmap polygons in which a raplacement took place 
+ the original reference points (blue circles)
+ correctly replaced reference points (yellow circles)
+ not correctly replaced reference points (red circles)
+ all potential repclacements with relative grts-ranking within polygon (black dots)



```{r}

habmap_pol <- habmap$habitatmap_polygons %>%
    select(polygon_id_check = polygon_id)

replacement <- assessments_admin_new_2021 %>%
    filter(distance > 2) %>%
    st_as_sf(coords = c("x_measured", "y_measured"), crs = 31370) %>%
    mutate(grts_ranking_new = grts_master[as(., "Spatial")]) %>%
    st_join(habmap_pol) %>%
    mutate(in_same_polygon = polygon_id_check == polygon_id)

replaced_from <- assessments_admin_new_2021 %>%
    filter(distance > 2) %>%
    st_as_sf(coords = c("x_original", "y_original"), crs = 31370) 


su_replacement_2021 <- read.csv2("../../output/replacements_inbo_versie2021-04-29.csv") 

su_replacement_polygon <- su_replacement_2021 %>%
   filter(polygon_id %in% replaced_from$polygon_id) %>%
    st_as_sf(coords= c("x", "y"), crs = 31370)

replacement <- replacement %>%
    group_by(point_code) %>%
    mutate(distance_grid = min(st_distance(geometry, su_replacement_polygon))) %>%
    ungroup() %>%
    mutate(on_grts_grid = drop_units(distance_grid) < 2,
           allow_replacement = on_grts_grid & in_same_polygon,
           show_color = ifelse(allow_replacement, "yellow", "red")) 
               

habmap_pol_replacement <- habmap_pol %>%
   filter(polygon_id_check %in% replaced_from$polygon_id)

leaflet() %>%
    addTiles() %>%
    addPolygons(data = st_transform(habmap_pol_replacement, 4326)) %>%
     addCircleMarkers(data = st_transform(replaced_from, 4326), color = "blue") %>%
    addCircleMarkers(data = st_transform(replacement, 4326), color = ~show_color) %>%
    addCircleMarkers(data = st_transform(su_replacement_polygon, 4326), color = "black", radius = 1, label = ~rank_inpolygon)
   
```




## Updated assessments

```{r}
mhq_terr_assessments_diff <- mhq_terr_assessments %>%
    anti_join(assessments_admin_long, by = c("point_code", "type_target")) %>%
    filter(!is.na(assessment_date))

mhq_terr_assessments_match <- mhq_terr_assessments %>%
    semi_join(assessments_admin_long, by = c("point_code", "type_target")) %>%
    filter(!is.na(assessment_date)) %>%
    select(point_code, type_target, type_observed, assessment_source, assessment_date, inaccessible) %>%
    arrange(type_target, point_code) %>%
    mutate(type_target = as.character(type_target),
           assessment_source = as.character(assessment_source))

assessments_admin_match <- assessments_admin_long %>%
    semi_join(mhq_terr_assessments_match, by = c("point_code", "type_target")) %>%
    select(point_code, type_target, type_observed, assessment_source, assessment_date, inaccessible, lsvi_measurement) %>%
    arrange(type_target, point_code)

compare <- assessments_admin_match %>%
    left_join(mhq_terr_assessments_match, by = c("point_code", "type_target"), suffix = c("_admin", "_table"))

update_type_observed <- compare %>%
    filter(type_observed_table != type_observed_admin & !is.na(type_observed_admin))

update_inaccessible <- compare %>%
    filter(is.na(inaccessible_table) & !is.na(inaccessible_admin) )

assessments_admin_update <- update_type_observed %>%
    bind_rows(update_inaccessible)
```





## Read standardized table of mhq refpoints, assessments and measurements

```{r}
mhq_terr_assessments <- read_vc("mhq_terr_assessments", 
                                root = "../../data")

# mhq_terr_assessments <- mhq_terr_assessments %>%
#   mutate(type_observed = str_trim(type_observed))
# 
# write_vc(mhq_terr_assessments, "mhq_terr_assessments",
#                                 root = "../../data", strict = FALSE)

mhq_terr_refpoints <- read_vc("mhq_terr_refpoints", 
                                root = "../../data")

mhq_terr_refpoints_check_update <- read_vc("mhq_terr_refpoints_check_update", 
                                root = "../../data")
    
mhq_terr_measurements <- read_vc("mhq_terr_measurements", 
                                root = "../../data")

mhq_terr_refpoints_validity <- read_vc("mhq_terr_refpoints_validity", 
                                root = "../../data")
```

# Update standardized tables

+ check for new assessments

```{r}
assessments_admin_done <- assessments_admin %>%
    filter(!is.na(assessment_date)) %>%
    rename(x_measured = x,
           y_measured = y)

assessments_table_todo <- mhq_terr_assessments %>%
    filter(is.na(assessment_date)) 

check_no_assessments <- all(is.na(assessments_table_todo$is_type_target)) &
     all(is.na(assessments_table_todo$assessment_source)) &
    all(is.na(assessments_table_todo$inaccessible))
    
assessments_table_new <- assessments_table_todo %>%
    select(point_code, type_target, x, y, fieldwork_team) %>%
    inner_join(assessments_admin_done, by = c("point_code", "fieldwork_team")) %>%
    mutate(distance_to_refpoint = sqrt((x_measured - x)^2 + (y_measured - y)^2),
           is_type_target = type_target == type_observed,
           is_type_target = ifelse(type_target == "2190" & type_observed == "2190_overig", TRUE, is_type_target),
           is_type_target = ifelse(is.na(is_type_target) & !lsvi_measurement, FALSE, is_type_target))

check_records <- assessments_table_new %>%
    filter(is.na(is_type_target) | is.na(lsvi_measurement))

```

Following records contain missing information:

```{r, results= 'asis'}
check_records %>%
    select(point_code, type_target, db_ref, assessment_date, assessment_source, lsvi_measurement, type_observed) %>%
    kbl() %>%
  kable_styling()
```
For following records the target type is observed but lsvi is not measured:

```{r}
check_records2 <- assessments_table_new %>%
  filter(is_type_target) %>%
  filter(!lsvi_measurement)

check_records2 %>%
    select(point_code, type_target, db_ref, assessment_date, assessment_source, lsvi_measurement, type_observed) %>%
    kbl() %>%
    kable_styling()
```


+ check for repeated assessments


```{r}
assessments_table_done <- mhq_terr_assessments %>%
    filter(!is.na(assessment_date))
  
assessments_admin_repeat <- assessments_admin_done %>%
    anti_join(assessments_table_new, by = c("point_code", "assessment_date")) %>%
    anti_join(assessments_table_done, by = c("point_code", "assessment_date"))

check_repeated_ass <- nrow(assessments_admin_repeat) > 0
  
```

+ check for anomalies

```{r}
assessments_table_done_check <- assessments_table_done %>%
  left_join(assessments_admin_done, by = c("point_code", "assessment_date"), suffix = c(".table", ".admin")) %>%
  mutate(match_assessment_source = assessment_source.table == assessment_source.admin,
         match_type_observed = type_observed.table == type_observed.admin)

check_type_observed <- assessments_table_done_check %>%
  filter(!match_type_observed)

check_missing_admin <- assessments_table_done_check %>%
  filter(is.na(lsvi_measurement))
```

+ check allow_other_types

```{r}
max_ranking <- mhq_terr_refpoints %>%
    filter(!is.na(grts_ranking_draw)) %>%
    group_by(type_target, sac) %>%
    summarise(max_grts_ranking_draw = max(grts_ranking_draw)) %>%
    ungroup() %>%
    rename(type_observed = type_target)

assessments_table_new <- assessments_table_new %>%
  mutate(type_observed = ifelse(type_observed == "2190_overig", "2190", type_observed)) %>%
  left_join(max_ranking, by = c("sac", "type_observed")) %>%
  group_by(point_code, assessment_date) %>%
  mutate(is_type_target_plot = sum(is_type_target) > 0) %>%
  ungroup() %>%
  mutate(allow_other_type = ifelse(is_type_target_plot, NA, (grts_ranking_draw <= max_grts_ranking_draw) & !is.na(max_grts_ranking_draw)))
  
check_allow_other_type <- assessments_table_new %>%
  filter(lsvi_measurement) %>%
  filter(!allow_other_type)
```

Following measurements are not valid because the observed type differs from the taget type and the grts-ranking is higher than the maximum grts-ranking in the sample of the observed type.

```{r}
check_allow_other_type %>%
  select(point_code, type_target, assessment_date, type_observed, lsvi_measurement, grts_ranking_draw, max_grts_ranking_draw, allow_other_type) %>%
  kbl() %>%
  kable_styling()
```



## Update mhq_terr_assessments

+ Create new sampling units when is_type_target is FALSE and a LSVI measurement is performed. For a limited number of sampling units allow_other_type is FALSE. Yet, for pragmatic reasons, we will keep these sampling units, altough theoretically they are not valid.

```{r}
# assessments_table_new <- assessments_table_new %>%
#   select(point_code, db_ref, type_target, is_type_target, type_observed, assessment_date, assessment_source, x = x_measured, y = y_measured, inaccessible, fieldwork_team, lsvi_measurement, allow_other_type)

new_sampling_units_strict <- assessments_table_new %>%
    filter(lsvi_measurement) %>%
    # filter(!is_type_target & !is_type_target_plot) %>%
    filter(allow_other_type)

new_sampling_units <- assessments_table_new %>%
    filter(lsvi_measurement) %>%
    filter(!is_type_target & !is_type_target_plot) %>%
    #filter(allow_other_type) %>%
    mutate(type_target = factor(type_observed, levels = levels(types$type)),
           is_type_target = TRUE,
           allow_other_type = NA) %>%
    unique()

assessments_table_new <- assessments_table_new %>%
  bind_rows(new_sampling_units)

mhq_terr_assessments_update <- mhq_terr_assessments %>%
  anti_join(assessments_table_new, by = c("point_code", "fieldwork_team")) %>%
  bind_rows(select(assessments_table_new, point_code, db_ref, type_target, is_type_target, type_observed, assessment_date, assessment_source, x = x_measured, y = y_measured, inaccessible, fieldwork_team))
  
```

To update the other standardized tables we will need the coordinates of the measured sampling units.For now we work with the available data to determine het number of measured valid sampling units per type. 

## Update mhq_terr_refpoints

```{r}
new_refpoints <- new_sampling_units %>%
  mutate(sampling_unit_code = str_c(grts_ranking_draw, "_", type_target)) %>%
  select(sampling_unit_code, type_target, point_code, sac, grts_ranking_draw, x = x_measured, y = y_measured, db_ref)

mhq_terr_refpoints_update <- mhq_terr_refpoints_check_update %>%
  bind_rows(new_refpoints)


```


